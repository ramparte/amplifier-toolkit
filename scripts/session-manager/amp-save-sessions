#!/bin/bash
# amp-save-sessions - Save ALL running Amplifier sessions
# Scans for amplifier processes directly and extracts session IDs
# Supports multiple sessions per directory (multiple terminals in same VS Code window)

set -e

HISTORY_FILE="$HOME/.amplifier/session-history.json"

# Colors for output
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
RED='\033[0;31m'
NC='\033[0m'

echo -e "${BLUE}Scanning for running Amplifier sessions...${NC}"

# Find all running amplifier processes
sessions=()
unknown_count=0

for amp_pid in $(pgrep -f '/\.local/bin/amplifier' 2>/dev/null); do
    # Get command line
    cmdline=$(cat "/proc/$amp_pid/cmdline" 2>/dev/null | tr '\0' ' ') || continue
    
    # Skip diagnostic/grep commands
    [[ "$cmdline" == *"pgrep"* ]] && continue
    [[ "$cmdline" == *"Scanning"* ]] && continue
    
    # Get working directory
    amp_cwd=$(readlink "/proc/$amp_pid/cwd" 2>/dev/null) || continue
    
    # Get process start time
    proc_start=$(stat -c %Y /proc/$amp_pid 2>/dev/null) || continue
    
    # Try to find session ID from command line first
    session_id=""
    
    # Full UUID format
    session_id=$(echo "$cmdline" | grep -oP '[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}' | head -1)
    
    # Short ID format (8 chars after 'resume')
    if [[ -z "$session_id" ]]; then
        short_id=$(echo "$cmdline" | grep -oP 'resume\s+\K[0-9a-f]{8}' | head -1)
        if [[ -n "$short_id" ]]; then
            # Expand short ID to full UUID by finding matching session
            project_path=$(echo "$amp_cwd" | sed 's|^/||; s|/|-|g; s|^|-|')
            project_dir="$HOME/.amplifier/projects/$project_path/sessions"
            for d in "$project_dir"/"$short_id"*/; do
                if [[ -d "$d" ]]; then
                    session_id=$(basename "$d")
                    break
                fi
            done
        fi
    fi
    
    # If not in command line, try to correlate by timing
    if [[ -z "$session_id" ]]; then
        project_path=$(echo "$amp_cwd" | sed 's|^/||; s|/|-|g; s|^|-|')
        project_dir="$HOME/.amplifier/projects/$project_path/sessions"
        
        best_match=""
        best_diff=9999999
        
        for session_dir in "$project_dir"/*/; do
            [[ ! -d "$session_dir" ]] && continue
            dir_name=$(basename "$session_dir")
            [[ "$dir_name" == *"_"* ]] && continue  # skip sub-sessions
            
            metadata="$session_dir/metadata.json"
            [[ ! -f "$metadata" ]] && continue
            
            # Get session creation time
            created=$(jq -r '.created' "$metadata" 2>/dev/null)
            [[ -z "$created" || "$created" == "null" ]] && continue
            
            session_start=$(date -d "$created" +%s 2>/dev/null) || continue
            
            # Process started within 120 seconds of session creation = likely match
            diff=$((proc_start - session_start))
            [[ $diff -lt 0 ]] && diff=$((-diff))
            
            if [[ $diff -lt 120 && $diff -lt $best_diff ]]; then
                best_diff=$diff
                best_match="$dir_name"
            fi
        done
        
        session_id="$best_match"
    fi
    
    # If still no match, try finding by recent modification (for resumed sessions)
    if [[ -z "$session_id" ]]; then
        project_path=$(echo "$amp_cwd" | sed 's|^/||; s|/|-|g; s|^|-|')
        project_dir="$HOME/.amplifier/projects/$project_path/sessions"
        
        # Find sessions modified after process start (active sessions)
        for session_dir in "$project_dir"/*/; do
            [[ ! -d "$session_dir" ]] && continue
            dir_name=$(basename "$session_dir")
            [[ "$dir_name" == *"_"* ]] && continue
            
            events="$session_dir/events.jsonl"
            [[ ! -f "$events" ]] && continue
            
            mod_time=$(stat -c %Y "$events")
            # Session must have been modified AFTER process started and within last 5 min
            now=$(date +%s)
            if [[ $mod_time -gt $proc_start && $((now - mod_time)) -lt 300 ]]; then
                # This is a candidate - but we might have multiple
                # For now, just take the most recently modified
                if [[ -z "$session_id" ]] || [[ $mod_time -gt $best_mod ]]; then
                    session_id="$dir_name"
                    best_mod=$mod_time
                fi
            fi
        done
    fi
    
    # Report what we found
    if [[ -n "$session_id" ]]; then
        sessions+=("{\"session_id\": \"$session_id\", \"directory\": \"$amp_cwd\", \"amplifier_pid\": $amp_pid}")
        echo -e "  ${GREEN}✓${NC} $amp_cwd"
        echo -e "    Session: ${session_id:0:8}..."
    else
        # Still save it with a placeholder so we know a session exists here
        sessions+=("{\"session_id\": \"UNKNOWN\", \"directory\": \"$amp_cwd\", \"amplifier_pid\": $amp_pid}")
        echo -e "  ${YELLOW}?${NC} $amp_cwd"
        echo -e "    Session: ${YELLOW}unknown${NC} (will use most recent on restore)"
        unknown_count=$((unknown_count + 1))
    fi
done

# Check if we found any sessions
if [[ ${#sessions[@]} -eq 0 ]]; then
    echo -e "${YELLOW}No running Amplifier sessions found.${NC}"
    echo ""
    echo "Tips:"
    echo "  - Make sure you have Amplifier sessions running"
    echo "  - This script finds 'amplifier' processes, not just open terminals"
    exit 0
fi

# Build JSON array of sessions
json_sessions=$(printf '%s\n' "${sessions[@]}" | jq -s '.')

# Get current timestamp
timestamp=$(date -Iseconds)

# Initialize history file if it doesn't exist
if [[ ! -f "$HISTORY_FILE" ]]; then
    mkdir -p "$(dirname "$HISTORY_FILE")"
    echo '{"saves": [], "next_id": 1}' > "$HISTORY_FILE"
fi

# Read current history and get next ID
current_history=$(cat "$HISTORY_FILE")
next_id=$(echo "$current_history" | jq -r '.next_id')

# Create the new save entry
new_entry=$(jq -n \
    --arg id "$next_id" \
    --arg ts "$timestamp" \
    --argjson sessions "$json_sessions" \
    '{id: ($id | tonumber), saved_at: $ts, sessions: $sessions}')

# Append to history and increment next_id
updated_history=$(echo "$current_history" | jq \
    --argjson entry "$new_entry" \
    '.saves += [$entry] | .next_id += 1')

# Save updated history
echo "$updated_history" > "$HISTORY_FILE"

# Display summary
echo ""
echo -e "${GREEN}Saved ${#sessions[@]} session(s) as save #${next_id}${NC}"

# Group by directory for display
echo ""
echo "$json_sessions" | jq -r 'group_by(.directory) | .[] | 
    "  \(.[0].directory): \(length) session(s)" + 
    (if length > 1 then " ⚡" else "" end)'

if [[ $unknown_count -gt 0 ]]; then
    echo ""
    echo -e "${YELLOW}Note: $unknown_count session(s) have unknown IDs.${NC}"
    echo -e "      They will restore using 'amplifier resume' (most recent session)."
fi

echo ""
echo -e "${BLUE}History now contains $(echo "$updated_history" | jq '.saves | length') save(s)${NC}"
echo -e "To restore: ${GREEN}amp-restore-sessions${NC} or ${GREEN}amp-restore-sessions --list${NC}"
